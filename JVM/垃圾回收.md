#### 简述

垃圾回收主要针对堆内存，这里以官方的 `HotSpot JVM` 为例

***

#### 判断算法

> 垃圾回收之前需要确定堆中的哪些对象是垃圾

##### 1. 引用计数算法

对对象的被引用的次数进行计数，每当有一个地方引用它时计数器 +1、引用失效则 -1，引用计数大于 0 的对象被认为是存活对象

但是，引用计数算法存在对象之间循环引用的问题

##### 2. 可达性分析法

以 `GC Roots` 为根节点，根据引用关系向下搜索，搜索过程走过的路径称为引用链，如果某个对象到 `GC Roots` 间没有任何引用链相连（或者说从 `GC Roots` 到该对象不可达），说明该对象是不再被使用的对象

<img src="https://raw.githubusercontent.com/WeYan1223/Pic/master/JVM/垃圾回收-可达性分析.webp" alt="垃圾回收-可达性分析.webp (979×605) (raw.githubusercontent.com)" style="zoom:67%;" /> 

上图中，`Object1 ~ Object4` 都是可达，`Object5 ~ Object7` 都是不可达

`GC Roots` 可理解为肯定不能被回收的对象，以下对象可作为 `GC Roots`

> `tips`：直接或间接保存了堆里面的对象，但自己又不在堆里，那么它就是一个 `GC Root`

* 虚拟机栈中引用的对象（主要是栈帧的局部变量表中引用的对象）
* 方法区中静态属性引用的对象
* 方法区中常量引用的对象：比如 `StringTable`
* 所有被同步锁 `synchronized` 持有的对象
* 本地方法栈中 `JNI` 引用的对象

***

#### 回收算法

##### 1. 标记-清除

![垃圾回收-标记清除算法.webp (556×195) (raw.githubusercontent.com)](https://raw.githubusercontent.com/WeYan1223/Pic/master/JVM/垃圾回收-标记清除算法.webp) 

**过程**

* 标记所有需要回收的对象，统一回收所有被标记的对象
* 也可以反过来，标记存活的对象，回收未被标记的对象

**缺点**

* 执行效率不稳定，如果堆中存在大量需要回收的对象，此时需要进行大量标记和清除动作
* 内存空间碎片化，标记-清除之后会产生大量不连续的内存碎片，碎片过多可能会导致程序在分配大对象时无法找到满足条件的连续内存而不得不提前触发另一次垃圾回收

##### 2. 标记-复制

![垃圾回收-标记复制算法.webp (575×204) (raw.githubusercontent.com)](https://raw.githubusercontent.com/WeYan1223/Pic/master/JVM/垃圾回收-标记复制算法.webp) 

**过程**

将内存划分为大小相等的两块，每次只是用其中一块，当这一块内存用完就将存活的对象复制到另一块内存上，然后再把已使用过的那块内存空间一次清理掉

**缺点**

* 如果内存中多数对象存活，该算法会产生大量复制操作
* 空间浪费严重，可用内存空间减少为原来的一半

##### 3. 标记-整理

![垃圾回收-标记整理算法.webp (568×191) (raw.githubusercontent.com)](https://raw.githubusercontent.com/WeYan1223/Pic/master/JVM/垃圾回收-标记整理算法.webp) 

**过程**

让所有此存活的对象都向内存空间一端移动，然后回收掉边界以外的内存

**注意**

标记-清除是非移动式的回收算法，标记-整理是移动式的回收算法

移动会使内存回收变复杂（对象复制等）

不移动则内存分配更复杂（空闲分区链表等）

#### 分代回收

> 大部分 `JVM` 采用分代回收算法，将内存划分为不同区域，不同区域采用适当的回收算法
>
> 分代回收理论建立在两个分代假说上：
>
> * 弱分代假说：<u>绝大多数的对象的存活时间不长</u>
> * 强分代假说：<u>熬过越多次垃圾回收的对象，就越难被回收</u>

##### 1. 为什么分代

堆内存是虚拟机管理的内存中最大的一块，也是垃圾回收最频繁的一块区域，程序中所有对象的实例都存放在堆内存中，分代是为了提高对象内存分配和垃圾回收的效率，如果没有分代，所有的新对象和旧对象放在一起，随着程序的执行，堆内存需要频繁进行垃圾回收，而每次回收都要遍历所有的对象，会严重影响 `GC` 效率

##### 2. 如何分代回收

![垃圾回收-堆内存划分.webp (516×238) (raw.githubusercontent.com)](https://raw.githubusercontent.com/WeYan1223/Pic/master/JVM/垃圾回收-堆内存划分.webp) 

根据对象存活周期不同将堆内存划分为：新生代、老年代（比例为 2：1），其中新生代内存又划分为三部分：`Eden`、`S0`、`S1`（比例为 8：1：1）

每次分配内存，只使用 `Eden` 和其中一块 `Survivor` 空间，发生 `GC` 回收时，标记 `Eden` 和该 `Survivor` 空间中存活的对象，复制到另一块空闲的 `Survivor` 空间，然后直接把 `Eden` 和使用过的那块 `Survivor` 空间清理掉

> 新生代

根据弱分代假说，新生代里绝大多数对象存活时间不长，非常适合使用标记-复制回收算法，新生代触发的垃圾回收称之为 `Minor GC`

1. 绝大多数新创建的对象会存放在 `Eden` 区
2. 在 `Eden` 区执行第一次 `Minor GC` 后，存活的对象会被标记复制到其中一个 `Survivor` 空间，并清除 `Eden` 区
3. 此后每次 `Minor GC`，都会将 `Eden` 和使用中的 `Survivor` 区域中存活的对象，标记复制到另一块空闲中的`Survivor` 区，然后直接清理 `Eden` 和使用过的那块 `Survivor `空间
5. 每次 `Minor GC` 存活下来的对象年龄加 1，默认年龄为 15 的对象会被移动到老年代
6. 也有例外出现，对于一些大的对象（指需要占用大量连续内存空间的对象）则直接进入到老年代

> 老年代

根据强分代假说，老年代的对象是不太容易被回收的，老年代使用的是标记-整理算法，在老年代触发的垃圾回收称之为 `Major GC`

**Q1：**为什么老年代的回收耗时比新生代更长？

* 老年代内存占比更大，理论上回收的时间也更长
* 老年代使用的是标记-整理算法，清理完成内存后，还得把存活的对象重新排序整理成连续的空间

**Q2：**为什么老年代不使用和新生代一样的标记-复制算法呢？

新生代里绝大多数对象都是朝生夕死的，使用的标记-复制算法，空间占比可以8 : 1 : 1，但是老年代里对象存活率很高，这个占比明显不合适。如果占比设置得大 (例如50%)，又会浪费很多内存空间，而且由于对象很多都是存活的，复制移动也是一笔开销。所以标记-复制这个算法，不适合老年代这种对象存活率很高的区域。

**Q3：**标记-整理算法，每次整理都消耗大量时间，能不能优化一下？

通过设置一个阈值或者临界点，当内存碎片化程度还在这个阈值范围内的时候，仅采用标记-清除算法，只有超过这个阈值，才进行整理

***

#### 回收类型

针对 `HotSpot VM` 的实现，它里面的 `GC` 其实准确分类只有两大种

* 部分收集 `(Partial GC)`
  * 新生代收集 `(Minor GC / Young GC)`：只对新生代进行垃圾收集
  * 老年代收集 `(Major GC / Old GC)`：只对老年代进行垃圾收集，需要注意的是 `Major GC` 在有的语境中也用于指代整堆收集
  * 混合收集 `(Mixed GC)`：对整个新生代和部分老年代进行垃圾收集

* 整堆收集 `(Full GC)`：收集整个堆和方法区

##### 1. Minor GC

> 回收新生代

当新生代的 `Eden` 区满时触发 `Minor GC`

##### 2. Major GC

> 回收老年代

`CMS` 收集器中，当老年代满时会触发 `Major GC`，目前只有 `CMS` 收集器会有单独收集老年代的行为

##### 3. Full GC

> 回收整个堆和方法区

调用 `System.gc()` 时，只是建议系统执行 `Full GC`，不一定会执行

空间分配担保：确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间，所以在进行 `Minor GC` 之前，需要做一次判断：

* 若老年代的剩余连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 `Minor GC`
* 否则将进行 `Full GC`

##### 4. STW

`STW (Stop The World)`，所有类型的 `GC` 都会导致 `STW` 暂停所有应用线程，主要是在可达性分析算法中枚举 `GC Roots` 时导致所有应用线程停顿

- 分析工作必须在一个能确保一致性的快照中进行
- 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上
- 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证

> `OopMap` `(Ordinary Object Pointer Map)`

枚举 `GC Roots` 是比较耗时的，`GC` 进行扫描时，需要查看每个位置存储的是不是引用类型

* 如果是，其所引用的对象就不能被回收
* 如果不是，那就是基本类型，这些肯定是不会引用对象的

这种对 `GC` 无用的基本类型的数据非常多，每次 `GC` 都要去扫描，显然是非常浪费时间的，于是 `Hotspot` 采用空间换时间的方法，把栈上的引用类型的位置全部记录下来，这样到 `GC` 的时候就可以直接读取，而不用一个个扫描，这个用于存储引用类型的数据结构叫 `OopMap`

> 安全点

对于 `OopMap` 的更新，从直观上来说，需要在对象引用关系发生变化的时候修改，不过导致引用关系变化的指令非常多，不可能为每一条指令都生成 `OopMaps`，这也需要大量的额外空间

于是 `JVM` 选择在某些特定的位置才记录这些信息，这些位置就是安全点 `(Safepoint)`

程序只有执行到安全点的时候，才能够暂停，但是又不希望 `GC` 等待时间过长，因此一般选择如下位置作为安全点：

* 方法返回之前
* 调用某个方法之后
* 抛出异常的位置
* 循环的末尾

> 安全区域

安全区域指的是，在某段代码中，引用关系不会发生变化，线程执行到这个区域是可以安全停下进行 `GC` 的，因此也可以把安全区域看做是扩展的安全点

当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起 `GC` 时，就不必去管这些在安全区域内的线程了

***

#### 垃圾收集器

> 目前使用最多的是 CMS 和 G1 收集器

##### 1. 分代收集器

- **ParNew：** 一款多线程的收集器，采用复制算法，主要工作在 Young 区，可以通过 `-XX:ParallelGCThreads` 参数来控制收集的线程数，整个过程都是 STW 的，常与 CMS 组合使用。
- **CMS：** 以获取最短回收停顿时间为目标，采用“标记-清除”算法，分 4 大步进行垃圾收集，其中初始标记和重新标记会 STW ，多数应用于互联网站或者 B/S 系统的服务器端上，JDK9 被标记弃用，JDK14 被删除

##### 2. 分区收集器

- **G1：** 一种服务器端的垃圾收集器，应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能地满足垃圾收集暂停时间的要求。
- **ZGC：** JDK11 中推出的一款低延迟垃圾回收器，适用于大内存低延迟服务的内存管理和回收，SPECjbb 2015 基准测试，在 128G 的大堆下，最大停顿时间才 1.68 ms，停顿时间远胜于 G1 和 CMS。
- **Shenandoah：** 由 Red Hat 的一个团队负责开发，与 G1 类似，基于 Region 设计的垃圾收集器，但不需要 Remember Set 或者 Card Table 来记录跨 Region 引用，停顿时间和堆的大小没有任何关系。停顿时间与 ZGC 接近，下图为与 CMS 和 G1 等收集器的 benchmark。