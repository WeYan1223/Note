#### 简述

耦合度：表示两个类之间的关联程度

* 当一个类发生变化时对另一个类的影响很小，则称它们是低耦合耦合（松散耦合）
* 反之，如果变化的影响很大时，则称它们是高耦合（紧密耦合）

遵循六大原则，尽量降低软件设计的耦合度，以提高软件的可维护性、可扩展性和可复用性

***

#### 六大原则

##### 1. 开闭原则

软件实体（类、模块、函数等）应该对<u>扩展开放，对修改关闭</u>，即应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化

##### 2. [迪米特法则](https://tianweili.github.io/2015/02/12/设计模式六大原则-迪米特法则/)

只与直接朋友交谈，不跟陌生讲话，或者说一个对象应该对其他对象保持最少的了解

通俗来讲，耦合类的内部无论多复杂、如何实现，我都不需要知道，我只需要知道该类公开的方法、属性

##### 3. 单一职责

接口、类、方法不应该承担太多职责，否则当需要该对象的某一个职责时，不得不将其他职责全部包含进来（冗余）

* 降低类的复杂度、提高类的可读性、提高可维护性
* 降低由代码变更引起的风险（修改一个功能时，显著降低对其他功能的影响）

##### 4. 里氏替换

`Java` 继承的优点：

* 子类拥有父类的变量与方法，提高代码的复用性

* 子类还能添加自己的功能，提高代码的扩展性

但同时，也有如下缺点：

* 降低了代码的灵活性，父类会对子类有一种约束

* 增强了耦合性，当需要对父类代码修改时，必须考虑对子类的影响

扬长避短，引入里氏替换原则：如果对每一个类型为 `S` 的对象 `o1`，都有类型为 `T` 的对象 `o2`，使得以 `T` 定义的所有程序 `P` 在所有的对象 `o1` 代替 `o2` 时，程序 `P` 的行为没有变化，那么类型 `S` 是类型 `T` 的子类型

通俗来讲，所有引用基类的地方必须能透明地使用其子类的对象（即<u>只要有父类出现的地方，都可以用子类来替代，而且不会出现任何错误与异常</u>）

实现方式：

* 子类可以实现父类的抽象方法，但不能重写父类的非抽象方法

* 子类可以增加自己特有的方法

* 当子类重载父类方法时，方法的参数要比父类更宽松

* 当子类实现父类抽象方法时，方法的返回值要比父类更严格或相等

##### 5. 依赖倒置

高层模块不应该直接依赖底层模块，而是依赖底层模块的接口，说白了就是面向接口编程（先定好接口，具体实现再慢慢写）

##### 6 .接口隔离

接口尽量小，但是要有限度（对接口进行细化可以提高程序的灵活性，但是如果过小，则会造成接口数量过多）