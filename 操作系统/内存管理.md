> 虚拟内存是什么？

虚拟内存是一种内存管理技术，主要用来对内存的扩展和优化

操作系统为每个进程分配一套独立的虚拟内存地址，至于虚拟内存地址最终怎么映射到真实的物理内存地址，这由操作系统去管理

操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 中的内存管理单元（MMU）的映射关系转换变成物理地址，然后再通过物理地址访问内存



> 为什么要有虚拟内存？

* 内存扩展：将进程的虚拟内存地址空间扩展到比实际物理内存大得多，从而允许进程使用更多的内存
* 内存保护：通过虚拟内存可以实现内存保护，防止进程访问不属于它的物理内存地址



> 虚拟内存如何映射到物理内存？

* 内存分段
* 内存分页
* 段页式内存管理



> 什么是内存分段？

<u>将程序按照逻辑分为若干个段，如代码段、数据段、栈段、堆段等，不同段具有不同属性、权限</u>

分段机制下的虚拟内存地址由两部分组成：段选择因子和段内偏移量

<img src="https://raw.githubusercontent.com/WeYan1223/Pic/master/操作系统/内-内存分段.webp" alt="内-内存分段.webp (1382×1004) (raw.githubusercontent.com)" style="zoom:67%;" /> 

通过段选择因子的段号去索引段表，确定该段的基地址和界限，然后将段内偏移量与基地址相加得到最终的物理地址

缺点：

* 容易产生外部内存碎片
* 内存交换的效率低：每次内存交换，都需要把一大段连续的内存数据写到硬盘上



> 什么是内存分页？

<u>虚拟内存和物理内存空间切成一段段固定尺寸的大小，这样一个连续并且尺寸固定的内存空间称为页，在 Linux 下，每一页的大小为 4KB</u>

分页机制下的虚拟内存地址由两部分组成：页号和页内偏移量

<img src="https://raw.githubusercontent.com/WeYan1223/Pic/master/操作系统/内-内存分页.webp" alt="内-内存分页.webp (1067×797) (raw.githubusercontent.com)" style="zoom:67%;" /> 

根据页号去索引页表，获取该页面的物理地址，将该页的物理地址与页内偏移量相加得到最终的物理地址（注意，页表项同时也包含该页一些控制信息，例如：该页面是否被修改过、是否被访问过等等）

对于一级页表，在 32 位和页大小 4KB 的环境下，一个进程的页表需要装下 100 多万个页表项，并且每个页表项占用 4 字节大小，于是维护一个进程的页表需占用 4MB 大小的空间，要解决该问题，需要采用多级页表的解决方案

<img src="https://raw.githubusercontent.com/WeYan1223/Pic/master/操作系统/内-内存分页_多级页表.webp" alt="内-内存分页_多级页表.webp (1686×1146) (raw.githubusercontent.com)" style="zoom: 50%;" /> 

如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表，根据局部性原理，这样可以大大降低一个进程的维护页表需占用的内存空间



> 内存分页——按需分页

分页机制下，在加载程序的时候不再需要一次性都把程序加载到物理内存中，完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去

如果页表中存在对应物理内存的映射，则直接返回物理内存的地址，否则将引发一个缺页异常，从而陷入到内核中分配物理内存，返回对应的物理地址，然后更新页表



> 什么是段页式内存管理？

内存分段与内存分页组合使用，就是段页式内存管理

- 先将程序按照逻辑划分为若干段
- 接着再把每个段划分为若干页

虚拟内存地址结构由段号、段内页号和页内偏移量三部分组成

* 通过段号索引段表，得到页表起始地址，

- 通过段内页号索引页表，得到该页面的物理地址
- 该页的物理地址与页内偏移量相加得到最终的物理地址