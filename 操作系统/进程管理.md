#### 进程

> 什么是进程？

<u>可执行文件被装载到内存中，接着 CPU 会执行程序中的每一条指令，这个运行中的程序，就称为进程</u>

操作系统中，使用进程控制块 `Process Control Block (PCB)` 来描述进程，PCB 主要包含以下信息：

* 进程描述信息
  * 进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符
  * 用户标识符：进程归属的用户，用户标识符主要为共享和保护服务
* 进程控制信息
  * 进程当前状态，如 `new`、`ready`、`running`、`waiting`、 `blocked` 等
  * 进程优先级
* 资源分配信息
  * 内存信息，页表
  * I/O 状态信息，包括进程所等待的 I/O 设备、I/O 缓冲区等信息
* CPU 相关信息
  * 程序计数器，指向下一条要执行的指令的内存地址
  * 寄存器状态，保存了进程在执行过程中的寄存器值，以便在进程被切换回来时能够恢复执行状态

操作系统通常是通过链表的方式进行组织每个 PCB，把具有相同状态的进程链在一起，组成各种队列，比如：

- 将所有处于就绪状态的进程链在一起，称为就绪队列
- 把所有因等待某事件而处于等待状态的进程链在一起就组成各种阻塞队列

<img src="https://raw.githubusercontent.com/WeYan1223/Pic/master/操作系统/进-PCB状态链表组织.webp" alt="进-PCB状态链表组织.webp (1052×572) (raw.githubusercontent.com)" style="zoom:67%;" /> 



> 进程哪些状态？

<img src="https://raw.githubusercontent.com/WeYan1223/Pic/master/操作系统/进-进程状态.webp" alt="进-进程状态.webp (1007×332) (raw.githubusercontent.com)" style="zoom:67%;" /> 

- 运行状态 `(Running)`：该时刻进程占用 CPU
- 就绪状态 `(Ready)`：可运行，处于就绪队列等待被操作系统调度
- 阻塞状态 `(Blocked)`：该进程正在等待某一事件发生（如等待 I/O 操作完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行
- 创建状态 `(new)`：进程正在被创建时的状态
- 结束状态 `(Exit)`：进程正在从系统中消失时的状态



> 进程的上下文切换？

各个进程之间是共享 CPU 资源的，在不同的时候进程之间需要切换，一个进程切换到另一个进程运行，称为进程的上下文切换

进程的上下文可以理解为 PCB，当要运行另外一个进程的时候，需要拿到该进程的 PCB，然后将相关信息恢复到 CPU 中，这使得这个进程可以执行



> 进程间通信？

由于每个进程的用户空间都是独立的，但内核空间是每个进程共享的，所以进程间通信必须通过内核空间，进程间通信有以下几种方式：

* **管道**

  * 匿名管道 `(PIPE)`，只能用于父子进程或者兄弟进程间通信

    ````c
    int pipe(int fd[2])
    ````

    父进程在内核空间创建一个匿名管道并返回两个描述符：读取端描述符 `fd[0]`、写入端描述符 `fd[1]`

    使用 `fork` 创建子进程，创建的子进程会复制父进程的文件描述符，这样就做到了两个进程都有 `fd[0]`与 `fd[1]`

    那么父子进程或者兄弟进程就使用这两个描述符来对管道写入或读取数据（注意，数据只能在一个方向上流动，所以如果需要双向通信，则应该创建两个管道）

  * 具名管道 `(FIFO)`，可以在不相关的进程间通信。因为具名管道提前创建了一个类型为管道的设备文件，进程只要有该文件的描述符就可以通信

* **消息队列**：保存在内核空间中的消息链表，链表中的元素称为消息体

  消息体是用户自定义的数据类型，发送方和接收方需要提前约定消息体的数据类型，所以对于一个消息队列来说，里面的消息体的大小是固定的

  发送方向消息队列插入元素来发送数据，接收方监听消息队列来读取数据

  消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程，所以发送到消息队列的数据太大，需要拷贝的时间也就越多

* **共享内存**：不同进程之间共享同一段物理内存，进程可以将同一段物理内存连接到他们自己的地址空间中，所有的进程都可以访问共享内存中的地址，如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程

  但是，多进程共享内存容易产生冲突，这时候需要一定的保护机制：信号量

* **信号量**：信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，信号量表示资源的数量，控制信号量的方式有两种原子操作：

  - P 操作，表示请求资源，信号量自减 1，相减后如果信号量 < 0，则表明资源已被占用，进程需阻塞等待
  - V 操作，表示释放资源，信号量自增 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将相应进程唤醒运行

  信号初始化为 1，代表是**互斥信号量**，可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存

  信号初始化为 0，代表是**同步信号量**，可以保证进程 A 应在进程 B 之前执行

* **信号**：信号主要用于处理异常情况，在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义，常见的有 `SIGKILL` 信号，用来立即结束该进程

  进程一旦收到了信号，将执行相应的函数进行处理，也就是说先把可能出现的异常等问题准备好，一旦信号产生就执行相应的逻辑即可

* **Socket**：主要用于不同主机上的进程通信，当然也可以用于同主机上进程间通信

  ```c
  int socket(int domain, int type, int protocal)
  ```

  根据 Socket 的类型不同，分为三种常见的通信方式

  * 基于 TCP 协议的通信方式
  * 基于 UDP 协议的通信方式
  * 本地进程间通信方式



#### 线程

> 什么是线程？

<u>线程是进程当中的一条执行流程，多个线程共享进程的资源，如相同的内存空间、进程信息等，但每个线程都为何自己独立的寄存器和栈信息，这样可以确保线程的控制流是相对独立的</u>

<img src="https://raw.githubusercontent.com/WeYan1223/Pic/master/操作系统/进-多线程内存结构.webp" alt="进-多线程内存结构.webp (855×834) (raw.githubusercontent.com)" style="zoom:67%;" /> 

- 一个进程中可以同时存在多个线程，各线程并发执行
- 线程之间可以共享地址空间和文件等资源



> 线程的上下文切换？

线程是 CPU 调度的基本单位，线程的上下文切换需要保存和恢复一部分线程的状态信息，包括：

* 寄存器内容：包括通用寄存器、程序计数器、堆栈指针等
* 堆栈内容：用于保存函数调用的信息
* 线程状态：包括就绪、运行、等待等状态



> 进程和线程的区别？

线程与进程的比较如下：

- 进程是资源（包括内存、打开的文件等）分配的基本单位，线程是 CPU 调度的基本单位
- 进程拥有完整的资源，而线程共享进程的资源并且只独享必不可少的资源，如寄存器和栈
- 线程能减少并发执行的时间和空间开销



> 为什么有了进程还要有线程？

- 进程中会存在多个任务，如果只有一条执行流，那么当某个任务被阻塞时，其他任务将得不到执行，因此需要线程使这些任务可以并发执行
- 线程比进程更轻量，线程间切换的开销更小



> 多线程互斥与同步？

* **锁**：任何想进入临界区的线程，必须先执行加锁操作。若加锁操作顺利通过，则线程可进入临界区；在完成对临界资源的访问后再执行解锁操作，以释放该临界资源

  * 忙等待锁：获取不到锁时，线程一直 while 循环来尝试获得锁
  * 无等待锁：获取不到锁时，把当前线程放入到锁的等待队列，然后执行调度程序，把 CPU 让给其他线程执行

* **信号量**：信号量其实是一个整型的计数器，表示资源的数量，控制信号量的方式有两种原子操作：

  - P 操作，表示请求资源，信号量自减 1，相减后如果信号量 < 0，则表明资源已被占用，线程需阻塞等待
  - V 操作，表示释放资源，信号量自增 1，相加后如果信号量 <= 0，则表明当前有阻塞中的线程，于是会将相应线程唤醒运行

  信号初始化为 1，代表是**互斥信号量**，可以保证临界区在任何时刻只有一个线程在访问

  信号初始化为 0，代表是**同步信号量**，可以保证线程 A 应在线程 B 之前执行



> 悲观锁、乐观锁？

悲观锁：认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁（如果并发冲突较为频繁，或者对数据一致性要求较高，则可以选择悲观锁）

乐观锁：假定冲突的概率很低，通常使用 CAS 等原子操作来更新共享资源，如果更新失败，则说明存在并发冲突，需要重新尝试更新（如果并发冲突较少，或者对性能要求较高，则可以选择乐观锁）



> 死锁？

两个线程都在等待对方释放锁，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了死锁

死锁产生的条件：

* 互斥条件：资源任何时刻只由一个线程占有

* 请求与保持：线程因请求资源而阻塞时，不会释放已经获取的资源

* 不可剥夺：线程已经获得的资源，在未使用完时不会被其他线程剥夺

* 循环等待：在死锁发生的时候，两个线程获取资源的顺序构成了环形链

要避免死锁，只需破坏其中一个条件