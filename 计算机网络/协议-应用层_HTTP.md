#### 概述

`HTTP (Hypertext Transfer Protocol)`，超文本传输协议，处于应用层

通俗来讲，`HTTP` 是在<u>计算机世界里专门在两点之间传输文字、图片、音频、视频、超链接等数据的约定和规范</u>

`HTTP` 主要用于 `Web` 应用中，定义了客户端和服务器之间传输数据的格式、语法和规则，是 `Web` 应用中最常用的协议之一

**主要特点**

* 请求-响应：应用 `HTTP` 时，必定是一端担任客户端角色，另一端担任服务器角色，客户端向服务器发送请求，服务器接收到请求后，返回响应
* 无状态：每个请求都是独立的，服务器只会根据请求返回相应的响应，而不会记录之前的请求和响应，这样可以简化服务器的设计和管理

***

#### 报文结构

> 用于 `HTTP` 交互的信息称为 `HTTP` 报文，客户端发送的称为请求报文，服务器返回的称为响应报文

请求报文和响应报文的结构基本相同，由三大部分组成：

1. 起始行（`start line`）：描述请求或响应的基本信息
2. 首部字段（`header`）：以 `key-value` 形式更详细地说明报文
3. 报文主体（`entity/body`）：实际传输的数据，不一定是纯文本，也可以是图片、视频等二进制数据

![HTTP_报文结构.webp (212×188) (raw.githubusercontent.com)](https://raw.githubusercontent.com/WeYan1223/Pic/master/计算机网络/HTTP_报文结构.webp) 

##### 1. 起始行

请求报文中的起始行称为请求行，请求行由三部分组成

1. 请求方法：是一个动词，常用的由 `GET` 和 `POST`，表示对资源的操作
2. 请求目标：通常是一个 `URI`，标记了请求方法要操作的资源
3. 版本号：表示报文使用的 `HTTP` 版本

```http
GET /index.html HTTP/1.1
```

响应报文中的起始行称为状态行，状态行由三部分组成

1. 版本号：表示报文使用的 HTTP 版本
2. 状态码：三位数，表示处理的结果，例如 200 是成功，500 是服务器错误
3. 原因：作为状态码补充，是更详细的解释文字

```http
HTTP/1.1 200 OK
```

##### 2. 首部字段

每个字段都是 `key-value` 格式，`key` 与 `value` 之间用 `:` 分隔，以 `CR + LF` 表示该字段结束，例如

````http
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Connection: keep-alive
````

`HTTP` 规定了许多的首部字段以实现各种各样的功能，但基本上可以分为四大类：

* 通用字段：在请求头和响应头里都可以出现

* 请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件

* 响应字段：仅能出现在响应头里，补充说明响应报文的信息

* 实体字段：它实际上属于通用字段，但专门用来描述报文主体的额外信息

##### 3. 报文主体

`HTTP` 报文可以没有 `body`，但必须要有 `start line + header`，而且 `start line + header` 后也必须要有空行

***

#### 常用字段

##### 1. 通用字段

- Date：创建报文的日期时间
- Connection：控制长连接
- Cache-Control：缓存过期时间，绝对时间（用于强制缓存）
- Transfer-Encoding：指定报文主体的传输编码方式

##### 2. 请求字段

* Host：发送请求时，用来指定服务器的域名
* User-Agent： HTTP 客户端的信息
* Accept-Encoding：用于告知服务器自己可以接受哪些压缩方法
* Accept-Language：用于告知服务器自己可以接受哪些自然语言
* Accept-Charset：用于告知服务器自己可以接受哪些字符集
* If-Modified-Since：上次响应中的 Last-Modified（用于协商缓存）
* If-None-Match：上次响应中的 ETag（用于协商缓存）

##### 3. 响应字段

- Server： HTTP 服务器的信息
- Location：重定向至指定 URI
- ETag：唯一标识该资源的字符串（用于协商缓存）
- Last-Modified：资源的最后修改日期时间（用于协商缓存）

##### 4. 实体字段

* Content-Length：报文主体的大小（单位：字节）
* Content-Encoding：报文主体的压缩方法
* Content-Type：报文主体的数据格式
* Content-Language：报文主体的自然语言
* Expires：缓存过期时间，相对时间（用于强制缓存）

***

#### 缓存机制

> `HTTP` 缓存用于存储与请求关联的响应，并将存储的响应复用于后续请求，有如下优点
>
> * 由于不需要将请求传递到服务器，因此响应速度是比较快的
> * 在一定程度上减少服务器上的负载
>
> `HTTP` 缓存有两种实现方式，分别是**强制缓存**与**协商缓存**

##### 1. 强制缓存

> 只要浏览器判断缓存没有过期，则直接使用本地缓存（决定是否使用缓存的主动性在浏览器这边）

强制缓存利用 `HTTP` 响应头部的如下字段实现，均表示资源在客户端缓存的有效期

* `Cache-Control`：相对时间
* `Expires`：绝对时间

`Cache-Control` 的优先级高于 `Expires` 且选项更多，所以建议使用 `Cache-Control` 实现强制缓存，具体流程如下

1. 浏览器第一次访问服务器资源，服务器在返回资源的同时，在响应头加上 `Cache-Control` 设置缓存过期时间，并将该资源缓存到本地
2. 浏览器再次访问服务器该资源时，先通过访问时间与缓存中的 `Cache-Control` 进行判断缓存是否过期，若没有过期，则使用该缓存，否则重新访问服务器
3. 服务器再次收到请求后，同样会在响应头加上 `Cache-Control`，浏览器对缓存进行更新

##### 2. 协商缓存

> 浏览器与服务器协商之后，通过协商结果判断是否使用本地缓存

协商缓存有两种实现方式：

**2.1 If-Modified-Since 与 Last-Modified**

1. 浏览器第一次访问服务器资源，服务器在返回资源的同时，在响应头加上 `Last-Modified` 标识该资源的最后修改时间，并将该资源缓存到本地
2. 浏览器再次访问服务器该资源时，发现本地存在缓存但未命中强制缓存，则发请求时设置请求头中 `If-Modified-Since` 字段的值为缓存中的 `Last-Modified` 值，服务器发现请求头存在 `If-Modified-Since` 字段，则与被请求资源的最后修改时间对比，对比结果若资源未被修改，则响应 `HTTP 304`，否则响应 `HTTP 200` 并返回修改后的资源

**2.2 If-None-Match 与 ETag**

1. 浏览器第一次访问服务器资源，服务器在返回资源的同时，在响应头加上 `ETag` 唯一标识响应资源
2. 浏览器再次访问服务器该资源时，发现本地存在缓存但未命中强制缓存，则发请求时设置请求头中 `If-None-Match` 字段的值为缓存中的 `ETag` 值，服务器收到请求进行对比，对比结果若资源未被修改，则响应 `HTTP 304`，否则响应 `HTTP 200` 并返回修改后的资源

第一种方式基于时间实现，第二种方式基于唯一标识实现，后者更能准确判断资源是否被修改

* 在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求
* 可能有些文件是在秒级以内修改的，`Last-Modified` 能检查到的粒度是秒级的，使用 `ETag` 就能够保证这种需求下客户端在 1 秒内能刷新多次
* 有些服务器不能精确获取文件的最后修改时间

##### 3. 注意事项

* 如果请求头同时带上 `ETag` 与 `Last-Modified`，此时 `ETag` 的优先级 > `Last-Modified`，即服务器会像判断 `ETag` 是否变化，如果是则不用再比较 `Last-Modified`，否则再比较 `Last-Modified` 判断是否过期

***

#### 常见状态码

**2xx** 类状态码表示服务器成功处理了客户端的请求：

* **200 OK**：表示一切正常，如果是非 `HEAD` 请求，响应通常带有 `body` 数据
* **204 No Content**：与 `200 OK` 基本相同，但响应没有 `body` 数据
* **206 Partial Content**：是应用于 `HTTP` 分块下载或断点续传，表示响应返回的 `body` 数据并不是资源的全部，而是其中的一部分

**3xx** 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 `URL` 重新发送请求获取资源，也就是重定向：

* **300 Moved Permanently**：表示永久重定向，说明请求的资源已经不存在了，需要使用新的 `URL` 再次访问
* **302 Found**：表示临时重定向，说明请求的资源还在，但暂时需要用另一个 `URL` 访问
* **304 Not Midified**：不具有跳转的含义，表示资源未修改，即客户端可以使用本地缓存，用于缓存控制

**4xx** 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义：

* **400 Bad Request**：表示客户端请求的报文有错误，但只是个笼统的错误
* **403 Forbidden**：表示服务器禁止访问资源，并不是客户端的请求出错
* **404 Not Found**：表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端

**5xx** 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码：

* **500 Internal Server Error**：与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道
* **501 Not Implemented**：表示客户端请求的功能还不支持，类似即将开业，敬请期待的意思
* **502 Bad Gatewa**：通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误
* **503 Service Unavailable**：表示服务器当前很忙，暂时无法响应客户端，类似网络服务正忙，请稍后重试的意思

***

#### Cookie

> `HTTP` 协议是无状态的，服务器不跟踪、不记录过去的请求，会导致完成有关联性的操作时非常麻烦

客户端第一次请求后，服务器在响应头添加 `Set-Cookie` 返回，客户端将 `Set-Cookie`  的内容保存到本地，之后请求服务器在请求头加上 `Cookie`，服务器通过检查 `Cookie` 来进行一些操作，比如确认身份等

***

#### 历史发展

##### 1. HTTP 1.0

> `HTTP/1.0` —— 基于 `TCP/IP` 的无状态无连接的应用层协议，基本报文格式为 `header + body`，其中 `header` 也是 `key-value` 简单文本格式
>
> 优点：简单
>
> 缺点：性能不佳，不安全

**无状态**

服务器不跟踪、不记录过去的请求

无状态引发的问题可以借助 **cookie/session** 机制来做身份认证与状态记录

**无连接**

浏览器每次发送 `HTTP` 请求都需要建立 `TCP` 连接，即无法复用 `TCP` 连接，而 `TCP` 连接释放过程比较耗时，因此该特性会使得网络利用率非常低

**队头阻塞**

`HTTP/1.0` 规定下一个请求必须在上一个请求响应到达之后才能发送，假设请求响应一直不到达，此时后面的请求将被阻塞

**不安全**

* 通信使用明文，内容可能会被窃听
* 不验证通信方的身份，可能遭遇伪装
* 无法证明报文的完整性，报文有可能遭篡改，例如网页上的垃圾广告

`HTTP` 的安全问题，可以用 [HTTPS](#HTTPS) 解决，通过在 `HTTP` 与 `TCP` 之间引入 `SSL/TLS` 层，保障安全性

##### 2. HTTP 1.1

> 1.1 版本继承了 1.0 版本的简单，同时克服了 1.0 上的性能问题

**长连接**

`HTTP 1.1` 默认使用长连接，即建立 `TCP` 连接后，只要任意一端没有明确提出断开连接，则保持 `TCP` 连接状态（当然如果连接超过一段时间没有任何数据交互，服务端会主动断开连接），可以设置 `Connection` 字段的值为 `close` 关闭长连接

<u>对于`HTTP 1.0` 仍提供了长连接选项，不过需要手动在请求头设置 `Connection` 字段的值为 `Keep-Alive`</u>

**管道传输**

在同一个 `TCP` 连接中，客户端可以发起多个请求，只要第一个请求发出去了，不必等待请求响应即可发送第二个请求，可以减少整体的响应时间，但是服务器必须按照请求顺序做出响应，如果服务器处理一个请求耗时较长，那么后续的请求处理都会被阻塞，即造成**响应的队头阻塞**

`HTTP 1.1` 管道传输解决了请求的队头阻塞，但不能解决响应的对头阻塞

<u>需要注意，`HTTP 1.1` 的管道技术不是默认开启，且浏览器基本都没有支持该功能</u>

##### 4. HTTP 2.0 

> `HTTP/2.0` 基于 `HTTPS` 协议

**并发传输**

`HTTP/1.1` 的实现基于<u>请求-响应</u>模型，同一个 `TCP` 连接中，`HTTP` 完成一个事务才能处理下一个事务，同时有可能造成队头阻塞问题

`HTTP/2.0` 引出 `Stream` 概念，多个 `Stream` 复用在同一条 `TCP` 连接，以实现并发传输，解决了队头阻塞问题

**头部压缩**

在客户端与服务器个缓存一张<u>头部信息表</u>，所有字段都会存入该表，生成对应的索引号，之后头部信息使用索引号代替，极大地压缩 `header` 大小，在一定程度上减少发送的包体积

**服务器推送**

客户端和服务器双方都可以建立 `Stream`，客户端建立的 `Stream ID` 必须是奇数，服务器建立的 `Stream ID` 必须是偶数

##### 5. HTTP 3.0

> `HTTP/3.0` 的下层协议改为 `UDP`

`UDP` 包的发送是无序的，并且是不可靠传输，但是基于 `UDP` 的 `QUIC` 协议可以实现类似 `TCP` 的可靠传输

`HTTP/3.0` 在 `HTTP` 与 `UDP` 之间加入了 `QUIC` 协议保障可靠性

**无队头阻塞**

`QUIC` 协议具有类似 `HTTP/2.0` 的 `Stream` 与多路复用概念，并且当某个流发生丢包时，只会阻塞当前流，其他流不会受到影响，因此不存在队头阻塞问题 

**更快建立连接**

对于 `HTTP/1` 与 `HTTP/2` 协议，`TCP` 与 `SSL/TLS` 是分层的，所以需要线 `TCP` 握手，再 `SSL/TLS` 握手

而 `QUIC` 协议内部包含了 `SSL/TLS`，仅需 1 个 `RTT` 即可同时完成建立连接与密钥协商

**连接迁移**

基于 `TCP` 的 `HTTP` 协议，通过四元组（<u>源 IP、源端口、目的 IP、目的端口</u>）唯一确定一条 `TCP` 连接，当移动设备从 4G 网络切换到 `WIFI` 时，意味着 `IP` 发生变化了，此时需要断开连接并重新建立连接

而 `QUIC` 协议通过<u>连接 ID</u>来标记通信的两个端点，即使 `IP` 地址变化了，只要仍保有上下文信息（比如连接 `ID`、`TLS` 密钥等），就可以无缝地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了连接迁移的功能

#### HTTPS

> `HTTP` 协议采用明文传输，存在安全风险，`HTTPS` 在 `HTTP` 与 `TCP` 之间引入 `SSL/TLS` 安全协议，使得报文能够加密传输
>
> `HTTP` 默认端口为 80，`HTTPS` 默认端口为 443

`HTTP` 明文传输，存在以下风险

* 窃听风险：通信链路上可以获取通信内容
* 篡改风险：例如网站植入的垃圾广告
* 冒充风险：客户端无法验证服务端是否冒充的

`HTTPS` 在 `HTTP` 与 `TCP` 之间加入了 `SSL/TLS` 协议，可以很好保证上面的风险

* 信息加密：数据就算被获取了也无法解密
* 校验机制：无法篡改通信内容，篡改了就不能正常显示
* 身份证书：能保证服务端是真的

**混合加密**

* `TLS` 握手过程采用<u>非对称加密</u>
* 通信过程采用<u>对称加密</u>

采用混合加密的原因：

* 对称加密只使用一个密钥，运算速度快，但是密钥必须自己保存
* 非对称加密使用两个密钥，公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题，但速度慢

**TLS握手过程**

> `TLS` 握手的主要目的在于
>
> * 协商通信使用的 `TLS` 版本
> * 客户端验证服务端身份
> * 

`TLS` 握手过程涉及四次通信，也称为<u>四次握手</u>，使用不同的公钥算法，握手流程也不一样，常用的有 `RSA` 算法与 `ECDHE` 算法，这里分析 `RSA`

1. `Client Hello`：首先由客户端向服务器发起加密通信请求，在这一步，客户端主要向服务器发送以下信息
   * 客户端支持的 `TLS` 协议版本
   * 客户端支持的密码算法列表
   * 客户端生成的随机数 `Client Random`（用于后续的<u>通信密钥</u>生成）
2. `Server Hello`：服务器收到客户端加密请求后，向客户端发出响应
   * 确认 `TLS` 协议版本
   * 确认的密码算法
   * 服务器的数字证书
   * 服务器生成的随机数 `Server Random`（用于后续<u>通信密钥</u>生成）
3. 客户端回应：客户端收到服务器回应后，通过浏览器或操作系统中的 `CA` 公钥，确认服务器数字证书的真实性，如果证书没有问题，客户端从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：
   * 一个随机数 `Premaster Secret`
   * 加密通信算法改变通知，表示该请求之后的信息都将使用<u>通信密钥</u>加密
   * 客户端握手结束通知
4. 服务器最后回应：
   * 加密通信算法改变通知，表示随后的信息都将用<u>通信密钥</u>加密
   * 服务器握手结束通知

注意，上面的 3、4 步客户端和服务器都使用相同的密码算法，并使用 `Client Random`、`Server Random`、`Premaster Secret` 生成相同的<u>通信密钥</u>

至此，`TLS` 四次握手结束，接下来客户端与服务器进入加密通信，使用普通的 `HTTP` 协议，只不过用<u>通信密钥</u>加密内容

**数字证书**

> 数字证书由数字证书认证机构（`CA`）颁发给服务端，用于验证服务端的真实性

在非对称加密过程中，服务器需要将公钥发送给客户端，但此时公钥很可能被第三方拦截，然后第三方就可以冒充服务器与客户端进行通信，这就是<u>中间人攻击</u>，数字证书可有效解决此类问题：

* 服务器将公钥注册到权威机构 `CA`
* `CA` 用自己的私钥将服务器的公钥数字签名，并办法数字证书
* 客户端拿到服务器的数字证书后，使用 `CA` 的公钥确认数字证书的真实性（`CA` 的公钥事先置入到了浏览器或操作系统中）
* 验证真实后，从数字证书可以获取服务器的真实公钥
