#### 概述

> `TCP/IP` 分层模型中，<u>`IP` 协议位于网络层，它不保证网络包的交付、不保证网络包的顺序、也不保证网络包中数据的完整性</u>，那么这些工作就需要上层（传输层）的 `TCP` 协议去完成

`TCP, Transmission Control Protocol`，传输控制协议，是一种**面向连接的**、**可靠的**、**基于字节流**的传输层通信协议

* 面向连接：`TCP` 通信前必须建立 `TCP` 连接（三次握手），一个 `TCP` 连接由<u>源地址、源端口、目的地址、目的端口（`TCP` 四元组）</u>唯一确定，所谓 `TCP` 连接，实质上是通过 `TCP` 协议头的信息使<u>通信双方维护着某些状态信息</u>
* 可靠的：`TCP` 可确保接收端的网络包是<u>无损坏、无间隔、非冗余、按序的</u>（注意 `TCP` 也不是 100% 可靠，它能够做到的是，如果可以就把数据发送到接收方，否则就通知用户。因此它所能提供的是数据的可靠递送和故障的可靠通知）
* 字节流：应用程序通过 `TCP` 发送数据时，`TCP` 将这些数据视为一系列字节流，并将它们分割成小的数据段（也称为 `TCP` 包）进行传输，数据段的大小取决于数据的实际情况和网络的状况

***

#### 协议头

<img src="https://raw.githubusercontent.com/WeYan1223/Pic/master/计算机网络/TCP_头部.webp" alt="TCP_头部.webp (1053×828) (raw.githubusercontent.com)" style="zoom: 67%;" /> 

**1. 序列号（Sequence Number）**

> 序列号在建立 `TCP` 连接（三次握手）时初始化，之后每次发送的 `TCP` 包序列号 + 1

* 唯一标识该 TCP 包

* 解决包乱序问题

* 去除重复数据

**2. 确认应答号（Acknowledgment Number）**

> 确认应答号也是在建立 `TCP` 连接（三次握手）时初始化，表示我下一次希望收到的 `TCP` 包的序列号（即确认应答号之前的包都被我正常接收了）

当接收方收到数据包后，会发送一个确认应答包（`ACK` 包），其中包含一个确认应答号，表示接收方已成功接收到前面所有数据包的数据，并期望接收下一个序号的数据包

**3. 控制位**

> 包含多个标志位，用于控制 `TCP` 连接的建立、维护和关闭

- ACK：该位为 1 时，确认应答号变为有效（TCP 规定，除了最初建立连接时的 SYN 包之外，该位必须设置为 1）
- RST：该位为 1 时，重置连接
- SYN：该位为 1 时，表示希望建立连接，并设置序列号的初始值
- FIN：该位为 1 时，表示发送方今后不会再有数据发送，希望断开连接

**4. 窗口大小**

接收窗口大小

**5. 校验和**

用于检测到数据包在传输过程中是否发生了差错

发送方在计算校验和时会先将报文中的校验和字段置零，然后基于整个报文（头部 + 数据部分）计算出校验和

接收方在收到报文后也会以相同方式计算校验和

- 如果计算结果符合期望值，说明数据包没有收到干扰或损坏
- 如果不符合期望，一般会直接丢弃该数据包

**6. 紧急指针**



#### 三次握手

> `TCP` 通信前必须建立连接，建立过程称为 `TCP` 三次握手（有限状态机）

<img src="https://raw.githubusercontent.com/WeYan1223/Pic/master/计算机网络/TCP_三次握手.webp" alt="TCP_三次握手.webp (1221×1019) (raw.githubusercontent.com)" style="zoom: 67%;" /> 

**流程**

第一次握手：

* 客户端发送 `SYN` 报文（表示向服务端发起连接）：`syn` 设为 1，随机初始化序列号为 `client_isn`
* 客户端处于 `SYN_SENT` 状态

第二次握手：

* 服务端主动监听某个端口，处于 `LISTEN` 状态
* 服务端收到 `SYN` 报文后：`syn` 和 `ack` 设为 1，随机初始化序列号为 `server_isn`，确认应答号设为 `client_isn + 1`，向客户端发送 `SYN + ACK` 报文
* 服务端处于 `SYN_RCVD` 状态

第三次握手：

* 客户端收到 `SYN + ACK` 报文后，还要向服务端回应建立连接的最后一个 `ACK` 报文：`ack` 设为 1，序列号设为 `client_isn + 1`，确认应答号设为 `server_isn + 1`，同时该报文可以携带数据
* 客户端处于 `ESTABLISHED` 状态
* 服务端收到客户端建立连接的最后一个 `ACK` 报文后，也进入 `ESTABLISHED` 状态

**分析**

> 为什么需要三次握手？
>
> 为什么不是两次握手？
>
> 无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号
>
> 为什么不是四次握手？
>
> 三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数

`TCP` 连接，实质上是通信双方维护着某些状态信息，包括 `TCP` 四元组、序列号、确认号、当前状态、窗口大小等等

* 保证正确地初始化这些状态信息

* 能保证双方具有发送与接收能力

  * 第一次握手：说明客户端具有发送能力
  * 第二次握手：说明服务端具有发送与接收能力
  * 第三次握手：说明客户端具有发送与接收能力

* <u>防止重复历史连接的初始化</u>（**重点**）

  首先，客户端先发送了 `SYN (Seq = 90)` 报文，然后客户端宕机了，接着客户端重启后，又重新向服务端发起建立连接请求，发送了新的 `SYN (Seq = 100)` 报文，这时候由于各种因素，新旧报文到达的顺序是不确定的：

  * 新 `SYN` 先到，旧 `SYN` 后到

    服务端处理 `SYN` 的策略是：

    - 新收到：响应建立半连接
    - 已有半连接：忽略，保护已有半连接
    - 已有完整连接：直接忽略

  * 旧 `SYN` 先到，新 `SYN` 后到

    在二次握手时，客户端发现确认号不正确，会发起 `RST` 报文终止连接

  如果只有两次握手，服务端在收到 `SYN` 报文后，就进入 `ESTABLISHED` 状态（建立连接），但是客户端此时还没有进入 `ESTABLISHED` 状态，假设客户端判断到此次连接为历史连接，那么就会回 `RST` 报文来断开连接，而服务端在第一次握手的时候就建立连接，会造成资源浪费

  总的来说，<u>在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端建立一个历史连接，造成资源浪费</u>，<u>在三次握手的情况下， 服务端存在中间状态 `SYN_RCVD` 给客户端来阻止历史连接，从而保证建立的连接不是历史连接</u>

* 避免资源浪费

***

#### 四次挥手

> `TCP` 断开连接是通过**四次挥手**方式，双方都可以主动断开连接，这里以客户端主动断开连接为例

<img src="https://raw.githubusercontent.com/WeYan1223/Pic/master/计算机网络/TCP_四次挥手.webp" alt="TCP_四次挥手.webp (753×794) (raw.githubusercontent.com)" style="zoom:67%;" /> 

**流程**

第一次挥手：

* 客户端发送 `FIN` 报文：`fin` 设为 1，表示客户端今后不会再有数据发送，希望断开连接
* 客户端处于 `FIN_WAIT_1` 状态

第二次挥手：

* 服务端收到该报文后，向客户端发送 `ACK` 应答报文
* 服务端进入 `CLOSE_WAIT` 状态（此时服务端可能还有数据要发送）
* 客户端收到 `ACK` 报文后，处于 `FIN_WAIT_2` 状态

第三次挥手：

* 服务端发送完数据后，向客户端发送 `FIN` 报文，表示服务端端今后不会再有数据发送，希望断开连接
* 服务端处于 `LAST_ACK` 状态

第四次挥手：

- 客户端接收到服务端的 `FIN` 包，并发送 `ACK` 确认包给服务端，此时客户端将进入 `TIME_WAIT` 状态
- 服务端收到 `AC`K 确认包后，就进入了最后的 `CLOSE` 状态
- 客户端经过 `2MSL` 时间之后，也进入 `CLOSE` 状态

**分析**

> 第二次挥手和第三次挥手可以合在一起吗？

关闭连接时，客户端向服务端发送 `FIN` 仅仅表示客户端不再发送数据了但是还能接收数据

服务端收到客户端的 `FIN` 报文时，先回一个 `ACK` 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 `FIN` 报文给客户端来表示同意现在关闭连接。

所以，服务端的 `ACK` 和 `FIN` 一般都会分开发送，即第二次握手和第三次握手一般不可以合在一起，但是也有例外：<u>当被动关闭方（这里是服务端）在挥手过程中没有数据要发送并且「开启了 `TCP` 延迟确认机制」，那么第二和第三次挥手就会合并传输</u>

延迟确认机制：

- 当有响应数据要发送时，`ACK` 会随着响应数据一起立刻发送给对方
- 当没有响应数据要发送时，`ACK` 将会延迟一段时间，以等待是否有响应数据可以一起发送
- 如果在延迟等待发送 `ACK` 期间，对方的第二个数据报文又到达了，这时就会立刻发送 `ACK`

> 为什么处于 `TIME_WAIT` 状态需要等待 `2MSL` 才进入 `CLOSE` 状态？

`MSL (Maximum Segment Lifetime)`，报文最大生存时间，表示报文在网络上存在的最长时间，超过这个时间的报文将被丢弃

1. 防止历史连接中的数据，被后面相同四元组的连接错误的接收

   在这段时间内，网络中可能还存在着已经传输过的，但是由于延迟或其他原因而未被及时处理的数据，如果没有 `2MSL` 那么在这个时间段内新的TCP连接建立并使用了之前的端口号，而这些延迟的分节又被传输到了新的连接中，就可能会导致数据的混乱或错误，保持 `TIME_WAIT` 状态的时间为 `2MSL` 可以确保所有延迟的数据都已经被处理完毕

2. 保证被动关闭连接的一方（这里是服务端），能被正确优雅的关闭

   `TIME-WAIT` 作用是等待足够的时间以确保最后的 `ACK` 能让被动关闭方接收，从而帮助其正常关闭，如果没有 `TIME_WAIT` 那么客户端发送最后一个 `ACK` 就进入 `CLOSE` 状态，如果此时 `ACK` 丢失，那么服务端就会重传 `FIN`，客户端在收到重传的 `FIN` 报文后，就会回 `RST` 报文

***

#### 重传机制

##### 1. 超时重传

> 发送方发送数据时，当超过指定的时间没有收到对方的 `ACK` 确认报文，发送方就会重传该数据

在以下两种情况发生超时重传：

- 发送方的数据包丢失
- 接收方的确认应答丢失

`RTT, Round Trip Time`，指的数据发送时刻到接收到确认的时刻的差值，也就是包的往返时间

`RTO, Retransmission Timeout `，超时重传时间的值应该略大于 `RTT` 的值

- RTO 较时，重发就慢，丢了老半天才重发，没有效率，性能差
- RTO 较小时，会导致可能并没有丢就重发，会增加网络拥塞

##### 2. 快速重传

> 不以时间为驱动，而是以数据驱动重传

* 发送方发送了数据包 1、2、3、4
* 接收方收到了数据包 1，发送 `ACK 2` （表明 2 以前的数据已收到）
* 数据包 2 丢失，接收方收到数据包 3、4，返回两次 `ACK 2` （表明 2 以前的数据已收到）
* 这时发送方已经收到三个相同的 `ACK` 报文了，会在定时器过期之前，重传丢失的报文段

对于快速重传，还有一个问题：重传时，是重传一个，还是重传所有？

* `SACK, Selective Acknowledgment` 选择性确认

  这种方式需要在 `TCP` 头部选项字段加一个 `SACK` 的东西，它可以将已收到的数据信息发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据

* `Duplicate SACK`，其主要使用 `SACK` 来告诉发送方有哪些数据被重复接收了

***

#### 保活机制

`TCP` 连接建立之后，开启 `TCP keepalive` 的一端会启动一个计时器，超时后会向另一端发送一个探测报文。探测报文不包含任何数据，或者包含一个无意义的字节，对方主机必须处于下表中的 4 个状态之一，己方则根据对端状态作不同处理

|                 状态                 |                             处理                             |
| :----------------------------------: | :----------------------------------------------------------: |
|      对方主机仍在工作，并且可达      |                `TCP` 连接正常，重置保活计时器                |
|   对方主机崩溃（已关闭或正在重启）   |         `TCP` 连接不正常，经指定次数探测后，断开连接         |
|        对方主机崩溃并且已重启        | 重启后原连接已失效，对方不认识探测报文，响应 `RST` 报文断开连接 |
| 对方主机仍工作，但某些原因导致不可达 |         `TCP` 连接不正常，经指定次数探测后，断开连接         |

***

#### 滑动窗口

> 为什么需要滑动窗口？

`TCP` 每发送一个数据包，都要进行一次确认应答，收到应答后再发送下一个数据包，这样你来我往效率是比较低的

引入窗口概念后，分为发送窗口和接收窗口

**发送窗口**

发送窗口大小：无需等待确认应答，而可以继续发送数据的最大值

<img src="https://raw.githubusercontent.com/WeYan1223/Pic/master/计算机网络/TCP_滑动窗口_发送方.webp" alt="TCP_滑动窗口_发送方.webp (1428×513) (raw.githubusercontent.com)" style="zoom:67%;" /> 

- `SND.WND`：`Window`，表示发送窗口的大小（由接收方指定）
- `SND.UNA`：`Unacknoleged`，绝对指针，指向的是已发送但未收到确认的第一个字节的序列号
- `SND.NXT`：`Next`，绝对指针，指向未发送但可发送范围的第一个字节的序列号
- `SND.UNA` 加上 `SND.WND`，指向 #4 的第一个字节

**接收窗口**

接收窗口大小：未收到但可以收到的数据的最大值

<img src="https://raw.githubusercontent.com/WeYan1223/Pic/master/计算机网络/TCP_滑动窗口_接收方.webp" alt="TCP_滑动窗口_接收方.webp (1429×498) (raw.githubusercontent.com)" style="zoom:67%;" /> 

- `RCV.WND`：`Window`，表示接收窗口的大小（通告给发送方）
- `RCV.NXT`：`Next`，绝对指针，指向期望从发送方发送来的下一个数据字节的序列号
- `RCV.NXT` 加上 `RCV.WND`，指向 #4 的第一个字节

***

#### 流量控制

> 发送方不能无脑发送数据给接收方，需要考虑接受方的处理能力，若接收方处理不过来，会导致发送方重传，浪费网络资源
>
> 流量控制：<u>让发送方根据接收方实际接收能力来控制发送的数据量</u>

通过协议头的窗口大小字段，让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制

如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这时发送方会启动一个持续计时器，持续计时器超时就会发送窗口探测报文，接收方在确认这个探测报文时，会给出自己现在的接收窗口大小

- 如果接收窗口仍然为 0，那么发送方重新启动持续计时器；
- 如果接收窗口不是 0，那么死锁的局面就可以被打破了

窗口探测的次数一般为 3 次，每次大约 30-60 秒，3 次过后接收窗口还是 0 的话，就会发 `RST` 报文来中断连接

**糊涂窗口综合症**

> 接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节

`TCP + IP` 头有 40 个字节，为了传输那几个字节的数据，要搭上这么大的开销，这太不经济了，要解决糊涂窗口综合症，可以从以下两方面出发：

- 让接收方不通告小窗口给发送方
- 让发送方避免发送小数据

***

#### 拥塞控制

> 网络拥堵时发送大量数据包，会导致数据包时延、丢失等，这时 `TCP` 重传数据会导致网络负担更重，恶性循环被不断地放大
>
> 拥塞控制：<u>避免发送方的数据填满整个网络</u>

拥塞窗口 `cwnd` 是发送方维护的一个的变量，会根据网络的拥塞程度动态变化的

加入了拥塞窗口的概念后，发送窗口的值为<u>发送方的拥塞窗口</u>和<u>接收方接收窗口</u>中的最小值，即

````sh
SND.WND = min(cwnd, RCV.WND)
````

所以，拥塞控制本质上是动态调整 `cwnd`：

- 网络中没有出现拥塞，`cwnd` 增大
- 网络中出现了拥塞，`cwnd` 减少

动态调整 `cwnd` 主要依靠以下算法：

* 慢启动算法
* 拥塞避免算法
* 拥塞发生算法
* 快速恢复算法

##### 1. 慢启动

> `TCP` 建立连接完成后，初始化 `cwnd` 为 1，发送方每收到一个 `ACK`，`cwnd` 自增 1

<img src="https://raw.githubusercontent.com/WeYan1223/Pic/master/计算机网络/TCP_拥塞控制_慢启动.webp" alt="TCP_拥塞控制_慢启动.webp (1016×632) (raw.githubusercontent.com)" style="zoom:67%;" /> 

可以发现，慢启动的 `cwnd` 呈指数增长，慢启动门限 `ssthresh (slow start threshold)`

- `cwnd` < `ssthresh`，使用慢启动算法
- `cwnd` >= `ssthresh`，使用拥塞避免算法

##### 2. 拥塞避免

> 发送方每当收到一个 `ACK` 时，`cwnd` 自增 `1/cwnd`

<img src="https://raw.githubusercontent.com/WeYan1223/Pic/master/计算机网络/TCP_拥塞控制_拥塞避免.webp" alt="TCP_拥塞控制_拥塞避免.webp (872×731) (raw.githubusercontent.com)" style="zoom:67%;" /> 

拥塞避免算法使得 `cwnd` 增长速度缓慢，当网络进入拥塞状况出现丢包现象后，这时就会对丢失的数据包进行重传，当触发了重传机制，进入拥塞发生算法

##### 3. 拥塞发生

网络出现拥塞，发生数据包重传，重传机制主要有两种：

* 超时重传，触发超时重传时，`ssthresh` 和 `cwnd` 的值会发生变化：
  * `ssthresh` 设为 `cwnd/2`
  * `cwnd` 重置为初始值
  * 重新开始慢启动算法

* 快速重传：触发快速重传时，`TCP` 认为这种情况并不严重，则 `ssthresh` 和 `cwnd` 变化如下：
  - `cwnd = cwnd/2`
  - `ssthresh = cwnd`
  - 进入快速恢复算法

##### 4. 快速恢复

1. `cwnd = cwnd/2`
2. `ssthresh = cwnd`
3. 重新传输丢失的数据包（快速重传）
4. 将 `cwnd = ssthresh + 3`（这就是算法本身设置的）
5. 若发送方仍收到重复的 `ACK`，则每收到一个 `ACK`，`cwnd` 自增 1（尽快将丢失的数据包发给接收方，从而解决拥塞的根本问题）
6. 直至收到新的 `ACK`，退出快速恢复算法
7. `cwnd = ssthresh`，进入拥塞避免算法