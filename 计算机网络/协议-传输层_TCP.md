#### 概述

> `TCP/IP` 分层模型中，<u>`IP` 协议位于网络层，它不保证网络包的交付、不保证网络包的顺序、也不保证网络包中数据的完整性</u>，那么这些工作就需要上层（传输层）的 `TCP` 协议去完成

`TCP, Transmission Control Protocol`，传输控制协议，是一种**面向连接的**、**可靠的**、**基于字节流**的传输层通信协议

* 面向连接：`TCP` 通信前必须建立 `TCP` 连接（三次握手），一个 `TCP` 连接由<u>源地址、源端口、目的地址、目的端口（`TCP` 四元组）</u>唯一确定，所谓 `TCP` 连接，实质上是通过 `TCP` 协议头的信息使<u>通信双方维护着某些状态信息</u>
* 可靠的：`TCP` 可确保接收端的网络包是<u>无损坏、无间隔、非冗余、按序的</u>（注意 `TCP` 也不是 100% 可靠，它能够做到的是，如果可以就把数据发送到接收方，否则就通知用户。因此它所能提供的是数据的可靠递送和故障的可靠通知）
* 字节流：应用程序通过 `TCP` 发送数据时，`TCP` 将这些数据视为一系列字节流，并将它们分割成小的数据段（也称为 `TCP` 包）进行传输，数据段的大小取决于数据的实际情况和网络的状况

***

#### 协议头

<img src="https://raw.githubusercontent.com/WeYan1223/Pic/master/计算机网络/TCP_头部.webp" alt="TCP_头部.webp (1053×828) (raw.githubusercontent.com)" style="zoom: 67%;" /> 

**1. 序列号（Sequence Number）**

> 序列号在建立 `TCP` 连接（三次握手）时初始化，之后每次发送的 `TCP` 包序列号 + 1

* 唯一标识该 TCP 包

* 解决包乱序问题

* 去除重复数据

**2. 确认应答号（Acknowledgment Number）**

> 确认应答号也是在建立 `TCP` 连接（三次握手）时初始化，表示我下一次希望收到的 `TCP` 包的序列号（即确认应答号之前的包都被我正常接收了）

当接收方收到数据包后，会发送一个确认应答包（`ACK` 包），其中包含一个确认应答号，表示接收方已成功接收到前面所有数据包的数据，并期望接收下一个序号的数据包

**3. 控制位**

> 包含多个标志位，用于控制 `TCP` 连接的建立、维护和关闭

- ACK：该位为 1 时，确认应答号变为有效（TCP 规定，除了最初建立连接时的 SYN 包之外，该位必须设置为 1）
- RST：该位为 1 时，重置连接
- SYN：该位为 1 时，表示希望建立连接，并设置序列号的初始值
- FIN：该位为 1 时，表示发送方今后不会再有数据发送，希望断开连接

**4. 窗口大小**



**5. 校验和**



**6. 紧急指针**



#### 三次握手

> `TCP` 通信前必须建立连接，建立过程称为 `TCP` 三次握手（有限状态机）

<img src="https://raw.githubusercontent.com/WeYan1223/Pic/master/计算机网络/TCP_三次握手.webp" alt="TCP_三次握手.webp (1221×1019) (raw.githubusercontent.com)" style="zoom: 67%;" /> 

**流程**

第一次握手：

* 客户端发送 `SYN` 报文（表示向服务端发起连接）：`syn` 设为 1，随机初始化序列号为 `client_isn`
* 客户端处于 `SYN_SENT` 状态

第二次握手：

* 服务端主动监听某个端口，处于 `LISTEN` 状态
* 服务端收到 `SYN` 报文后：`syn` 和 `ack` 设为 1，随机初始化序列号为 `server_isn`，确认应答号设为 `client_isn + 1`，向客户端发送 `SYN + ACK` 报文
* 服务端处于 `SYN_RCVD` 状态

第三次握手：

* 客户端收到 `SYN + ACK` 报文后，还要向服务端回应建立连接的最后一个 `ACK` 报文：`ack` 设为 1，序列号设为 `client_isn + 1`，确认应答号设为 `server_isn + 1`，同时该报文可以携带数据
* 客户端处于 `ESTABLISHED` 状态
* 服务端收到客户端建立连接的最后一个 `ACK` 报文后，也进入 `ESTABLISHED` 状态

**分析**

> 为什么需要三次握手？
>
> 为什么不是两次握手？
>
> 无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号
>
> 为什么不是四次握手？
>
> 三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数

`TCP` 连接，实质上是通信双方维护着某些状态信息，包括 `TCP` 四元组、序列号、确认号、当前状态、窗口大小等等

* 保证正确地初始化这些状态信息

* 能保证双方具有发送与接收能力

  * 第一次握手：说明客户端具有发送能力
  * 第二次握手：说明服务端具有发送与接收能力
  * 第三次握手：说明客户端具有发送与接收能力

* <u>防止重复历史连接的初始化</u>（**重点**）

  首先，客户端先发送了 `SYN (Seq = 90)` 报文，然后客户端宕机了，接着客户端重启后，又重新向服务端发起建立连接请求，发送了新的 `SYN (Seq = 100)` 报文，这时候由于各种因素，新旧报文到达的顺序是不确定的：

  * 新 `SYN` 先到，旧 `SYN` 后到

    服务端处理 `SYN` 的策略是：

    - 新收到：响应建立半连接
    - 已有半连接：忽略，保护已有半连接
    - 已有完整连接：直接忽略

  * 旧 `SYN` 先到，新 `SYN` 后到

    在二次握手时，客户端发现确认号不正确，会发起 `RST` 报文终止连接

  如果只有两次握手，服务端在收到 `SYN` 报文后，就进入 `ESTABLISHED` 状态（建立连接），但是客户端此时还没有进入 `ESTABLISHED` 状态，假设客户端判断到此次连接为历史连接，那么就会回 `RST` 报文来断开连接，而服务端在第一次握手的时候就建立连接，会造成资源浪费

  总的来说，<u>在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端建立一个历史连接，造成资源浪费</u>，<u>在三次握手的情况下， 服务端存在中间状态 `SYN_RCVD` 给客户端来阻止历史连接，从而保证建立的连接不是历史连接</u>

* 避免资源浪费

***

#### 四次挥手

> `TCP` 断开连接是通过**四次挥手**方式，双方都可以主动断开连接，这里以客户端主动断开连接为例

<img src="https://raw.githubusercontent.com/WeYan1223/Pic/master/计算机网络/TCP_四次挥手.webp" alt="TCP_四次挥手.webp (753×794) (raw.githubusercontent.com)" style="zoom:67%;" /> 

**流程**

第一次挥手：

* 客户端发送 `FIN` 报文：`fin` 设为 1，表示客户端今后不会再有数据发送，希望断开连接
* 客户端处于 `FIN_WAIT_1` 状态

第二次挥手：

* 服务端收到该报文后，向客户端发送 `ACK` 应答报文
* 服务端进入 `CLOSE_WAIT` 状态（此时服务端可能还有数据要发送）
* 客户端收到 `ACK` 报文后，处于 `FIN_WAIT_2` 状态

第三次挥手：

* 服务端发送完数据后，向客户端发送 `FIN` 报文，表示服务端端今后不会再有数据发送，希望断开连接
* 服务端处于 `LAST_ACK` 状态

第四次挥手：

- 客户端接收到服务端的 `FIN` 包，并发送 `ACK` 确认包给服务端，此时客户端将进入 `TIME_WAIT` 状态
- 服务端收到 `AC`K 确认包后，就进入了最后的 `CLOSE` 状态
- 客户端经过 `2MSL` 时间之后，也进入 `CLOSE` 状态

**分析**

> 第二次挥手和第三次挥手可以合在一起吗？

关闭连接时，客户端向服务端发送 `FIN` 仅仅表示客户端不再发送数据了但是还能接收数据

服务端收到客户端的 `FIN` 报文时，先回一个 `ACK` 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 `FIN` 报文给客户端来表示同意现在关闭连接。

所以，服务端的 `ACK` 和 `FIN` 一般都会分开发送，即第二次握手和第三次握手一般不可以合在一起，但是也有例外：<u>当被动关闭方（这里是服务端）在挥手过程中没有数据要发送并且「开启了 `TCP` 延迟确认机制」，那么第二和第三次挥手就会合并传输</u>

延迟确认机制：

- 当有响应数据要发送时，`ACK` 会随着响应数据一起立刻发送给对方
- 当没有响应数据要发送时，`ACK` 将会延迟一段时间，以等待是否有响应数据可以一起发送
- 如果在延迟等待发送 `ACK` 期间，对方的第二个数据报文又到达了，这时就会立刻发送 `ACK`

> 为什么处于 `TIME_WAIT` 状态需要等待 `2MSL` 才进入 `CLOSE` 状态？

`MSL (Maximum Segment Lifetime)`，报文最大生存时间，表示报文在网络上存在的最长时间，超过这个时间的报文将被丢弃

1. 防止历史连接中的数据，被后面相同四元组的连接错误的接收

   在这段时间内，网络中可能还存在着已经传输过的，但是由于延迟或其他原因而未被及时处理的数据，如果没有 `2MSL` 那么在这个时间段内新的TCP连接建立并使用了之前的端口号，而这些延迟的分节又被传输到了新的连接中，就可能会导致数据的混乱或错误，保持 `TIME_WAIT` 状态的时间为 `2MSL` 可以确保所有延迟的数据都已经被处理完毕

2. 保证被动关闭连接的一方（这里是服务端），能被正确优雅的关闭

   `TIME-WAIT` 作用是等待足够的时间以确保最后的 `ACK` 能让被动关闭方接收，从而帮助其正常关闭，如果没有 `TIME_WAIT` 那么客户端发送最后一个 `ACK` 就进入 `CLOSE` 状态，如果此时 `ACK` 丢失，那么服务端就会重传 `FIN`，客户端在收到重传的 `FIN` 报文后，就会回 `RST` 报文

***

#### 重传机制

##### 1. 超时重传

> 发送方发送数据时，当超过指定的时间没有收到对方的 `ACK` 确认报文，发送方就会重传该数据

在以下两种情况发生超时重传：

- 发送方的数据包丢失
- 接收方的确认应答丢失

`RTT, Round Trip Time`，指的数据发送时刻到接收到确认的时刻的差值，也就是包的往返时间

`RTO, Retransmission Timeout `，超时重传时间的值应该略大于 `RTT` 的值

- RTO 较时，重发就慢，丢了老半天才重发，没有效率，性能差
- RTO 较小时，会导致可能并没有丢就重发，会增加网络拥塞

##### 2. 快速重传

> 不以时间为驱动，而是以数据驱动重传

* 发送方发送了数据包 1、2、3、4
* 接收方收到了数据包 1，发送 `ACK 2` （表明 2 以前的数据已收到）
* 数据包 2 丢失，接收方收到数据包 3、4，返回两次 `ACK 2` （表明 2 以前的数据已收到）
* 这时发送方已经收到三个相同的 `ACK` 报文了，会在定时器过期之前，重传丢失的报文段

对于快速重传，还有一个问题：重传时，是重传一个，还是重传所有？

* `SACK, Selective Acknowledgment` 选择性确认

  这种方式需要在 `TCP` 头部选项字段加一个 `SACK` 的东西，它可以将已收到的数据信息发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据

* `Duplicate SACK`，其主要使用 `SACK` 来告诉发送方有哪些数据被重复接收了

***

#### 保活机制

`TCP` 连接建立之后，开启 `TCP keepalive` 的一端会启动一个计时器，超时后会向另一端发送一个探测报文。探测报文不包含任何数据，或者包含一个无意义的字节，对方主机必须处于下表中的 4 个状态之一，己方则根据对端状态作不同处理

|                 状态                 |                             处理                             |
| :----------------------------------: | :----------------------------------------------------------: |
|      对方主机仍在工作，并且可达      |                `TCP` 连接正常，重置保活计时器                |
|   对方主机崩溃（已关闭或正在重启）   |         `TCP` 连接不正常，经指定次数探测后，断开连接         |
|        对方主机崩溃并且已重启        | 重启后原连接已失效，对方不认识探测报文，响应 `RST` 报文断开连接 |
| 对方主机仍工作，但某些原因导致不可达 |         `TCP` 连接不正常，经指定次数探测后，断开连接         |

***

#### 流量控制



***

#### 拥塞控制

