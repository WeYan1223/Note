#### 概述

> `TCP/IP` 分层模型中，<u>`IP` 协议位于网络层，它不保证网络包的交付、不保证网络包的顺序、也不保证网络包中数据的完整性</u>，那么这些工作就需要上层（传输层）的 `TCP` 协议去完成

`TCP, Transmission Control Protocol`，传输控制协议，是一种**面向连接的**、**可靠的**、**基于字节流**的传输层通信协议

* 面向连接：`TCP` 通信前必须建立 `TCP` 连接（三次握手），一个 `TCP` 连接由<u>源地址、源端口、目的地址、目的端口（`TCP` 四元组）</u>唯一确定，所谓 `TCP` 连接，实质上是通过 `TCP` 协议头的信息使<u>通信双方维护着某些状态信息</u>
* 可靠的：`TCP` 可确保接收端的网络包是<u>无损坏、无间隔、非冗余、按序的</u>（注意 `TCP` 也不是 100% 可靠，它能够做到的是，如果可以就把数据发送到接收方，否则就通知用户。因此它所能提供的是数据的可靠递送和故障的可靠通知）
* 字节流：应用程序通过 `TCP` 发送数据时，`TCP` 将这些数据视为一系列字节流，并将它们分割成小的数据段（也称为 `TCP` 包）进行传输，数据段的大小取决于数据的实际情况和网络的状况

***

#### 协议头

<img src="https://raw.githubusercontent.com/WeYan1223/Pic/master/计算机网络/TCP_头部.webp" alt="TCP_头部.webp (1053×828) (raw.githubusercontent.com)" style="zoom: 67%;" /> 

**1. 序列号（Sequence Number）**

> 序列号在建立 `TCP` 连接（三次握手）时初始化，之后每次发送的 `TCP` 包序列号 + 1

* 唯一标识该 TCP 包

* 解决包乱序问题

* 去除重复数据

**2. 确认应答号（Acknowledgment Number）**

> 确认应答号也是在建立 `TCP` 连接（三次握手）时初始化，表示我下一次希望收到的 `TCP` 包的序列号（即确认应答号之前的包都被我正常接收了）

当接收方收到数据包后，会发送一个确认应答包（`ACK` 包），其中包含一个确认应答号，表示接收方已成功接收到前面所有数据包的数据，并期望接收下一个序号的数据包

**3. 控制位**

> 包含多个标志位，用于控制 `TCP` 连接的建立、维护和关闭

- ACK：该位为 1 时，确认应答号变为有效（TCP 规定，除了最初建立连接时的 SYN 包之外，该位必须设置为 1）
- RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接
- SYN：该位为 1 时，表示希望建立连接，并设置序列号的初始值
- FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接

**4. 窗口大小**



**5. 校验和**



**6. 紧急指针**



#### 三次握手

> `TCP` 通信前必须建立连接，建立过程称为 `TCP` 三次握手（有限状态机）

<img src="https://raw.githubusercontent.com/WeYan1223/Pic/master/计算机网络/TCP_三次握手.webp" alt="TCP_三次握手.webp (1221×1019) (raw.githubusercontent.com)" style="zoom: 67%;" /> 

**流程**

第一次握手：

* 客户端发送 `SYN` 报文（表示向服务端发起连接）：`syn` 设为 1，随机初始化序列号为 `client_isn`
* 客户端处于 `SYN_SENT` 状态

第二次握手：

* 服务端主动监听某个端口，处于 `LISTEN` 状态
* 服务端收到 `SYN` 报文后：`syn` 和 `ack` 设为 1，随机初始化序列号为 `server_isn`，确认应答号设为 `client_isn + 1`，向客户端发送 `SYN + ACK` 报文
* 服务端处于 `SYN_RCVD` 状态

第三次握手：

* 客户端收到 `SYN + ACK` 报文后，还要向服务端回应建立连接的最后一个 `ACK` 报文：`ack` 设为 1，序列号设为 `client_isn + 1`，确认应答号设为 `server_isn + 1`，同时该报文可以携带数据
* 客户端处于 `ESTABLISHED` 状态
* 服务端收到客户端建立连接的最后一个 `ACK` 报文后，也进入 `ESTABLISHED` 状态

**分析**

> 为什么需要三次握手？
>
> 为什么不是两次握手？
>
> 无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号
>
> 为什么不是四次握手？
>
> 三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数

`TCP` 连接，实质上是通信双方维护着某些状态信息，包括 `TCP` 四元组、序列号、确认号、当前状态、窗口大小等等

* 保证正确地初始化这些状态信息

* 能保证双方具有发送与接收能力

  * 第一次握手：说明客户端具有发送能力
  * 第二次握手：说明服务端具有发送与接收能力
  * 第三次握手：说明客户端具有发送与接收能力

* <u>防止重复历史连接的初始化</u>（**重点**）

  首先，客户端先发送了 `SYN (Seq = 90)` 报文，然后客户端宕机了，接着客户端重启后，又重新向服务端发起建立连接请求，发送了新的 `SYN (Seq = 100)` 报文，这时候由于各种因素，新旧报文到达的顺序是不确定的：

  * 新 `SYN` 先到，旧 `SYN` 后到

    服务端处理 `SYN` 的策略是：

    - 新收到：响应建立半连接
    - 已有半连接：忽略，保护已有半连接
    - 已有完整连接：直接忽略

  * 旧 `SYN` 先到，新 `SYN` 后到

    在二次握手时，客户端发现确认号不正确，会发起 `RST` 报文终止连接

  如果只有两次握手，服务端在收到 `SYN` 报文后，就进入 `ESTABLISHED` 状态（建立连接），但是客户端此时还没有进入 `ESTABLISHED` 状态，假设客户端判断到此次连接为历史连接，那么就会回 `RST` 报文来断开连接，而服务端在第一次握手的时候就建立连接，会造成资源浪费

  总的来说，<u>在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端建立一个历史连接，造成资源浪费</u>，<u>在三次握手的情况下， 服务端存在中间状态 `SYN_RCVD` 给客户端来阻止历史连接，从而保证建立的连接不是历史连接</u>

* 避免资源浪费

***

#### 四次挥手