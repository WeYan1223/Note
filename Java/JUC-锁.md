#### 乐观锁悲观锁

> 根据访问共享资源需不需要上锁区分

##### 1. 乐观锁

总是假设最好的情况，每次去访问数据时都认为不会发生冲突，所以不会上锁，但是更新数据时会判断在此期间有没有其他线程更新这个数据（使用 `CAS` 算法实现）

适用场景：对共享数据的读操作比较多、写操作比较少

`Java` 中 `JUC` 包下的原子类就是使用 `CAS` 来实现乐观锁

##### 2. 悲观锁

总是假设最坏的情况，每次去访问数据时都认为一定发生冲突，所以每次访问数据时都会上锁

适用场景：对共享数据的写操作比较多

`Java` 中 `synchronized` 和 `ReentrantLock` 是悲观锁

***

#### 公平锁非公平锁

> 根据获取锁的顺序区分

##### 1. 公平锁

公平锁按照线程请求锁的顺序来获取锁，当多个线程等待同一个锁时，锁将按照先到先得的原则分配给线程

优点：公平锁保证了线程获取锁的公平性，避免饥饿情况的发生

缺点：公平锁的实现可能会带来一些额外的开销，因为需要维护一个等待队列来管理线程的获取顺序

`ReentrantLock` 默认是非公平锁，可以通过构造函数参数来指定为公平锁

##### 2. 非公平锁

非公平锁允许多个线程同时竞争获取锁，并不保证等待时间最长的线程先获取锁，有可能新请求锁的线程优先获取锁

优点：非公平锁的实现相对较为简单，性能上可能会比公平锁更好，因为不需要维护等待队列

缺点：在竞争激烈的情况下，可能会导致某些线程长时间等待，产生饥饿现象

`ReentrantLock` 默认是非公平锁，可以通过构造函数参数来指定为公平锁

`Java` 中 `synchronized` 是非公平锁，`ReentrantLock` 默认是非公平锁

***

#### 共享锁独占锁

> 根据是否允许多个线程获取同一个锁区分

##### 1. 共享锁

共享锁允许多个线程同时获取同一个锁

适用场景：对数据的读取操作，因为多个线程可以同时读取数据，不会互斥地阻塞彼此

`ReentrantReadWriteLock` 同时支持共享锁和独占锁，可以根据需要选择使用共享锁或独占锁来控制对共享资源的访问

##### 2. 独占锁

独占锁只允许一个线程独占地获取锁，其他线程必须等待该线程释放锁才能获取

使用场景：对数据的写入或修改操作，因为写操作需要确保数据的一致性，不允许并发访问

`Java` 中 `synchronized` 和 `ReentrantLock` 都是独占锁

***

#### 可重入锁非重入锁

> 根据一个线程能否多次获取同一把锁区分

##### 1. 可重入锁

可重入锁是支持同一个线程多次获取锁，可重入锁通过使用计数器来追踪获取锁的次数，每次获取锁计数器加一，释放锁计数器减一，直到计数器为零时锁完全释放

优点：避免死锁

`Java` 中 `synchronized` 和 `ReentrantLock` 都是可重入锁

##### 2. 非重入锁

非重入锁是支持同一个线程多次获取锁，当一个线程已经持有非重入锁时，如果再次尝试获取该锁，线程将被阻塞

缺点：容易造成死锁，所以基本没有非重入锁

***

#### 自旋锁

自旋锁是一种基于忙等待的非阻塞锁机制，线程在尝试获取锁时会循环检测锁的状态，直到锁被释放

优点：减少线程切换和上下文切换带来的开销，尤其在锁的持有时间很短的情况下，自旋锁的性能可能会比较好

缺点：如果锁的竞争激烈，或者锁被持有的时间较长，自旋锁可能会导致 `CPU` 资源白白浪费

`JUC` 原子类的修改操作的内部实现都是自旋锁，比如 `compareAndSet()` 不断尝试更新原子变量的状态，来实现多线程之间的同步

